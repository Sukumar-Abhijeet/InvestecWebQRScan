"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.contextUtils = exports.inferQuote = exports.inferIndent = exports.prettyPrint = exports.getAdjacentCombinators = exports.calleeIdentifier = exports.createRule = void 0;
var experimental_utils_1 = require("@typescript-eslint/experimental-utils");
var recast = __importStar(require("recast"));
var typescript_estree_1 = require("@typescript-eslint/typescript-estree");
var fp_ts_1 = require("fp-ts");
var function_1 = require("fp-ts/function");
var estraverse_1 = __importDefault(require("estraverse"));
var typescript_1 = __importDefault(require("typescript"));
var version = require("../package.json").version;
exports.createRule = experimental_utils_1.ESLintUtils.RuleCreator(function (name) {
    return "https://github.com/buildo/eslint-plugin-fp-ts/blob/v" + version + "/docs/rules/" + name + ".md";
});
function calleeIdentifier(node) {
    switch (node.type) {
        case experimental_utils_1.AST_NODE_TYPES.MemberExpression:
            if (node.property.type === experimental_utils_1.AST_NODE_TYPES.Identifier) {
                return fp_ts_1.option.some(node.property);
            }
            else {
                return fp_ts_1.option.none;
            }
        case experimental_utils_1.AST_NODE_TYPES.CallExpression:
            switch (node.callee.type) {
                case experimental_utils_1.AST_NODE_TYPES.Identifier:
                    return fp_ts_1.option.some(node.callee);
                case experimental_utils_1.AST_NODE_TYPES.MemberExpression:
                    if (node.callee.property.type === experimental_utils_1.AST_NODE_TYPES.Identifier) {
                        return fp_ts_1.option.some(node.callee.property);
                    }
                    else {
                        return fp_ts_1.option.none;
                    }
            }
            return fp_ts_1.option.none;
        case experimental_utils_1.AST_NODE_TYPES.Identifier:
            return fp_ts_1.option.some(node);
    }
}
exports.calleeIdentifier = calleeIdentifier;
function isWithinTypes(n, types) {
    return !!n && types.includes(n.type);
}
function getAdjacentCombinators(pipeOrFlowExpression, combinator1, combinator2, requireMatchingPrefix) {
    function matches(value, stringOrRegex) {
        if (typeof stringOrRegex === "string") {
            return value === stringOrRegex;
        }
        else {
            return !!value.match(stringOrRegex);
        }
    }
    var firstCombinatorIndex = pipeOrFlowExpression.arguments.findIndex(function (a, index) {
        if (isWithinTypes(a, combinator1.types) &&
            index < pipeOrFlowExpression.arguments.length - 1) {
            var b = pipeOrFlowExpression.arguments[index + 1];
            if (isWithinTypes(b, combinator2.types)) {
                return function_1.pipe(fp_ts_1.apply.sequenceS(fp_ts_1.option.option)({
                    idA: calleeIdentifier(a),
                    idB: calleeIdentifier(b),
                }), fp_ts_1.option.exists(function (_a) {
                    var idA = _a.idA, idB = _a.idB;
                    return matches(idA.name, combinator1.name) &&
                        matches(idB.name, combinator2.name);
                }));
            }
        }
        return false;
    });
    if (firstCombinatorIndex >= 0) {
        var firstCombinator = pipeOrFlowExpression.arguments[firstCombinatorIndex];
        var secondCombinator = pipeOrFlowExpression.arguments[firstCombinatorIndex + 1];
        if (requireMatchingPrefix) {
            // NOTE(gabro): this is a naive way of checking whether two combinators are
            // from the same module.
            // We assume the most commonly used syntax is something like:
            //
            // import { array } from 'fp-ts'
            // pipe(
            //   [1, 2],
            //   array.map(...),
            //   array.sequence(...)
            // )
            //
            // So we check that array.map and array.sequence have the same prefix ("array." in this example)
            // by pretty-printing it and comparing the result.
            //
            // This works well enough in practice, but if needed this can be made more exact by using
            // TypeScript's compiler API and comparing the types.
            var getPrefix = function (node) {
                switch (node.type) {
                    case experimental_utils_1.AST_NODE_TYPES.CallExpression:
                        return node.callee.type === experimental_utils_1.AST_NODE_TYPES.MemberExpression
                            ? prettyPrint(node.callee.object)
                            : "";
                    case experimental_utils_1.AST_NODE_TYPES.MemberExpression:
                        return prettyPrint(node.object);
                    case experimental_utils_1.AST_NODE_TYPES.Identifier:
                        return "";
                }
            };
            if (getPrefix(firstCombinator) === getPrefix(secondCombinator)) {
                return fp_ts_1.option.some([firstCombinator, secondCombinator]);
            }
        }
        else {
            return fp_ts_1.option.some([firstCombinator, secondCombinator]);
        }
    }
    return fp_ts_1.option.none;
}
exports.getAdjacentCombinators = getAdjacentCombinators;
function prettyPrint(node) {
    return recast.prettyPrint(node).code;
}
exports.prettyPrint = prettyPrint;
function inferIndent(node) {
    return new Array(node.loc.start.column + 1).join(" ");
}
exports.inferIndent = inferIndent;
function inferQuote(node) {
    return node.raw[0] === "'" ? "'" : '"';
}
exports.inferQuote = inferQuote;
var contextUtils = function (context) {
    function findModuleImport(moduleName) {
        var importNode = fp_ts_1.option.none;
        estraverse_1.default.traverse(context.getSourceCode().ast, {
            enter: function (node) {
                if (node.type === "ImportDeclaration" &&
                    experimental_utils_1.ASTUtils.getStringIfConstant(node.source) ===
                        moduleName) {
                    importNode = fp_ts_1.option.some(node);
                }
            },
            keys: typescript_estree_1.visitorKeys,
        });
        return importNode;
    }
    function findLastModuleImport() {
        var importNode = fp_ts_1.option.none;
        estraverse_1.default.traverse(context.getSourceCode().ast, {
            enter: function (node) {
                if (node.type === "ImportDeclaration") {
                    importNode = fp_ts_1.option.some(node);
                }
            },
            keys: typescript_estree_1.visitorKeys,
        });
        return importNode;
    }
    function addNamedImportIfNeeded(name, moduleName, quote, fixer) {
        return function_1.pipe(findModuleImport(moduleName), fp_ts_1.option.fold(function () {
            // insert full named import
            return function_1.pipe(findLastModuleImport(), fp_ts_1.option.fold(
            // no other imports in this file, add the import at the very beginning
            function () { return [
                fixer.insertTextAfterRange([0, 0], "import { " + name + " } from " + quote + moduleName + quote + "\n"),
            ]; }, function (lastImport) {
                // other imports founds in this file, insert the import after the last one
                return [
                    fixer.insertTextAfterRange([lastImport.range[0], lastImport.range[1] + 1], "import { " + name + " } from " + quote + moduleName + quote + "\n"),
                ];
            }));
        }, function (importDeclaration) {
            return function_1.pipe(importDeclaration.specifiers, fp_ts_1.array.findFirst(function (specifier) {
                return specifier.type === experimental_utils_1.AST_NODE_TYPES.ImportSpecifier &&
                    specifier.imported.name === name;
            }), fp_ts_1.option.fold(function () {
                // insert 'name' in existing module import
                return function_1.pipe(importDeclaration.specifiers, fp_ts_1.array.last, fp_ts_1.option.fold(
                // No specifiers, so this is import {} from 'fp-ts'
                // NOTE(gabro): It's an edge case we don't handle for now, so we just do nothing
                function () { return [fixer.insertTextAfterRange([0, 0], "")]; }, 
                // Insert import specifier, possibly inserting a comma if needed
                function (lastImportSpecifier) {
                    if (experimental_utils_1.ASTUtils.isCommaToken(context
                        .getSourceCode()
                        .getTokenAfter(lastImportSpecifier))) {
                        return [
                            fixer.insertTextAfter(lastImportSpecifier, " " + name),
                        ];
                    }
                    else {
                        return [
                            fixer.insertTextAfter(lastImportSpecifier, ", " + name),
                        ];
                    }
                }));
            }, function () {
                // do nothing, 'name' is already imported
                return [];
            }));
        }));
    }
    function removeImportDeclaration(node, fixer) {
        var nextToken = context.getSourceCode().getTokenAfter(node);
        if (nextToken && nextToken.loc.start.line > node.loc.start.line) {
            return fixer.removeRange([
                node.range[0],
                context.getSourceCode().getIndexFromLoc({
                    line: node.loc.start.line + 1,
                    column: 0,
                }),
            ]);
        }
        else {
            return fixer.remove(node);
        }
    }
    function isIdentifierImportedFrom(identifier, targetModuleName, context) {
        var _a, _b, _c;
        var importDef = (_a = experimental_utils_1.ASTUtils.findVariable(experimental_utils_1.ASTUtils.getInnermostScope(context.getScope(), identifier), identifier.name)) === null || _a === void 0 ? void 0 : _a.defs.find(function (d) { return d.type === "ImportBinding"; });
        return !!(((_b = importDef === null || importDef === void 0 ? void 0 : importDef.parent) === null || _b === void 0 ? void 0 : _b.type) === experimental_utils_1.AST_NODE_TYPES.ImportDeclaration && ((_c = importDef.parent.source.value) === null || _c === void 0 ? void 0 : _c.toString().match(targetModuleName)));
    }
    function isFlowExpression(node) {
        return function_1.pipe(node, calleeIdentifier, fp_ts_1.option.exists(function (callee) {
            return callee.name === "flow" &&
                isIdentifierImportedFrom(callee, /fp-ts\//, context);
        }));
    }
    function isPipeOrFlowExpression(node) {
        return function_1.pipe(node, calleeIdentifier, fp_ts_1.option.exists(function (callee) {
            return ["pipe", "flow"].includes(callee.name) &&
                isIdentifierImportedFrom(callee, /fp-ts\//, context);
        }));
    }
    function isOnlyUsedAsType(node) {
        if (node.type === experimental_utils_1.AST_NODE_TYPES.ImportSpecifier) {
            return function_1.pipe(experimental_utils_1.ASTUtils.findVariable(context.getScope(), node.imported.name), fp_ts_1.option.fromNullable, fp_ts_1.option.exists(function (variable) {
                var nonImportReferences = function_1.pipe(variable.references, fp_ts_1.array.filter(function (ref) { var _a; return ((_a = ref.identifier.parent) === null || _a === void 0 ? void 0 : _a.type) !== experimental_utils_1.AST_NODE_TYPES.ImportDeclaration; }));
                return function_1.pipe(nonImportReferences, fp_ts_1.array.every(function (ref) { var _a; return ((_a = ref.identifier.parent) === null || _a === void 0 ? void 0 : _a.type) === experimental_utils_1.AST_NODE_TYPES.TSTypeReference; }));
            }));
        }
        return false;
    }
    function parserServices() {
        return function_1.pipe(context.parserServices, fp_ts_1.option.fromNullable, fp_ts_1.option.filter(function (parserServices) { return parserServices.hasFullTypeInformation; }));
    }
    function typeOfNode(node) {
        return function_1.pipe(fp_ts_1.option.Do, fp_ts_1.option.bind("parserServices", parserServices), fp_ts_1.option.bind("typeChecker", function (_a) {
            var parserServices = _a.parserServices;
            return function_1.pipe(parserServices.program.getTypeChecker(), fp_ts_1.option.fromNullable);
        }), fp_ts_1.option.map(function (_a) {
            var parserServices = _a.parserServices, typeChecker = _a.typeChecker;
            var tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);
            return typeChecker.getTypeAtLocation(tsNode);
        }));
    }
    var compilerHost = function_1.pipe(parserServices(), fp_ts_1.option.map(function (parserServices) {
        return typescript_1.default.createCompilerHost(parserServices.program.getCompilerOptions());
    }));
    function isFromFpTs(type) {
        return function_1.pipe(parserServices(), fp_ts_1.option.exists(function (parserServices) {
            var _a, _b, _c;
            if (type.isUnion()) {
                var allFromFpTs = function_1.pipe(type.types, fp_ts_1.array.every(isFromFpTs));
                return allFromFpTs;
            }
            var declaredFileName = (_c = (_b = (_a = type.symbol) === null || _a === void 0 ? void 0 : _a.getDeclarations()) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.getSourceFile().fileName;
            if (declaredFileName) {
                return function_1.pipe(compilerHost, fp_ts_1.option.exists(function (compilerHost) {
                    return !!typescript_1.default.resolveModuleName("fp-ts", declaredFileName, parserServices.program.getCompilerOptions(), compilerHost).resolvedModule;
                }));
            }
            return false;
        }));
    }
    return {
        addNamedImportIfNeeded: addNamedImportIfNeeded,
        removeImportDeclaration: removeImportDeclaration,
        isFlowExpression: isFlowExpression,
        isPipeOrFlowExpression: isPipeOrFlowExpression,
        isIdentifierImportedFrom: isIdentifierImportedFrom,
        isOnlyUsedAsType: isOnlyUsedAsType,
        typeOfNode: typeOfNode,
        isFromFpTs: isFromFpTs,
        parserServices: parserServices,
    };
};
exports.contextUtils = contextUtils;
