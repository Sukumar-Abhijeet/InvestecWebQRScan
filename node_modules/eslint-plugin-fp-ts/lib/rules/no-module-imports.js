"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var experimental_utils_1 = require("@typescript-eslint/experimental-utils");
var fp_ts_1 = require("fp-ts");
var function_1 = require("fp-ts/function");
var utils_1 = require("../utils");
var messages = {
    importNotAllowed: "Importing from modules is not allowed, import from 'fp-ts' instead",
    importValuesNotAllowed: "Importing values from modules is not allowed, import from 'fp-ts' instead",
};
exports.default = utils_1.createRule({
    name: "no-module-imports",
    meta: {
        type: "problem",
        fixable: "code",
        docs: {
            description: "Disallow imports from fp-ts modules, such as `fp-ts/Option`",
            recommended: "error",
        },
        schema: [
            {
                type: "object",
                properties: {
                    allowTypes: {
                        type: "boolean",
                    },
                    allowedModules: {
                        type: "array",
                        items: {
                            type: "string",
                        },
                    },
                },
            },
        ],
        messages: {
            importNotAllowed: "Importing from modules is not allowed, import from 'fp-ts' instead",
            importValuesNotAllowed: "Importing values from modules is not allowed, import from 'fp-ts' instead",
        },
    },
    defaultOptions: [
        { allowedModules: ["function", "pipeable"], allowTypes: false },
    ],
    create: function (context, _a) {
        var _b;
        var options = _a[0];
        var allowTypes = options.allowTypes;
        var allowedModules = (_b = options.allowedModules) !== null && _b !== void 0 ? _b : [];
        var _c = utils_1.contextUtils(context), addNamedImportIfNeeded = _c.addNamedImportIfNeeded, isOnlyUsedAsType = _c.isOnlyUsedAsType, removeImportDeclaration = _c.removeImportDeclaration;
        return {
            ImportDeclaration: function (node) {
                var sourceValue = experimental_utils_1.ASTUtils.getStringIfConstant(node.source);
                if (sourceValue) {
                    var forbiddenImportPattern = /^fp-ts\/(.+)/;
                    var matches = sourceValue.match(forbiddenImportPattern);
                    if (matches != null) {
                        var matchedModule_1 = matches[1].replace("lib/", "");
                        if (allowedModules.includes(matchedModule_1)) {
                            return;
                        }
                        var importSpecifiers_1 = node.specifiers.filter(function (importClause) {
                            return importClause.type === experimental_utils_1.AST_NODE_TYPES.ImportSpecifier;
                        });
                        var nonTypeImports_1 = function_1.pipe(importSpecifiers_1, fp_ts_1.array.filter(function (i) { return !isOnlyUsedAsType(i); }));
                        if (allowTypes && nonTypeImports_1.length === 0) {
                            return;
                        }
                        if (importSpecifiers_1.length > 0) {
                            context.report({
                                node: node.source,
                                messageId: allowTypes
                                    ? "importValuesNotAllowed"
                                    : "importNotAllowed",
                                fix: function (fixer) {
                                    var indexExport = matchedModule_1.charAt(0).toLowerCase() +
                                        matchedModule_1.slice(1);
                                    var referencesFixes = importSpecifiers_1.flatMap(function (importSpecifier) {
                                        var variable = experimental_utils_1.ASTUtils.findVariable(context.getScope(), importSpecifier.local.name);
                                        if (variable) {
                                            return variable.references
                                                .filter(function (ref) {
                                                var _a;
                                                return allowTypes
                                                    ? ((_a = ref.identifier.parent) === null || _a === void 0 ? void 0 : _a.type) !==
                                                        experimental_utils_1.AST_NODE_TYPES.TSTypeReference
                                                    : true;
                                            })
                                                .filter(function (ref) {
                                                var _a;
                                                return ((_a = ref.identifier.parent) === null || _a === void 0 ? void 0 : _a.type) !==
                                                    experimental_utils_1.AST_NODE_TYPES.MemberExpression;
                                            })
                                                .map(function (ref) {
                                                return fixer.insertTextBefore(ref.identifier, indexExport + ".");
                                            });
                                        }
                                        else {
                                            return [];
                                        }
                                    });
                                    var importFixes = !allowTypes ||
                                        nonTypeImports_1.length === importSpecifiers_1.length
                                        ? [removeImportDeclaration(node, fixer)]
                                        : nonTypeImports_1.map(function (node) {
                                            var _a;
                                            if (((_a = context.getSourceCode().getTokenAfter(node)) === null || _a === void 0 ? void 0 : _a.value) === ",") {
                                                return fixer.removeRange([
                                                    node.range[0],
                                                    node.range[1] + 1,
                                                ]);
                                            }
                                            else {
                                                return fixer.remove(node);
                                            }
                                        });
                                    return __spreadArrays(importFixes, addNamedImportIfNeeded(indexExport, "fp-ts", utils_1.inferQuote(node.source), fixer), referencesFixes);
                                },
                            });
                        }
                    }
                }
            },
        };
    },
});
